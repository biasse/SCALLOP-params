from sage.all import *
from sage.schemes.elliptic_curves.hom_composite import EllipticCurveHom_composite
from quaternion import IdealGenerator, QuaternionOrderBasis, InverseIdeal, pullback
from xonly import customTwoIsogeny, xDBLMUL
from klpt import SpecialEichlerNorm, FindLinearCombination
from ec import CompleteBasis, TorsionBasis
from utilities import BiDLP

#################################
#                               #
#         Isogeny chains        #
#                               #
#################################

def chain_iso(kernelPointsIn, E):
    r"""
    Given points {P_1, ..., P_n} on curve E, outputs the isogeny
    whose kernel is generated by {P_1, ..., P_n}
    """
    kernelPoints = kernelPointsIn.copy()[::-1]
    Ei = E
    philist = []
    while kernelPoints:
        Ri, (l,e), coeffs = kernelPoints.pop()
        print(f'Computing isogeny of degree {l}')
        Ki = Ri.xMUL(l**(e-1))
        phi = Ki.xISOG(Ei, l)
        Ei = phi.codomain()
        if e > 1:
            kernelPoints.append((Ri, (l, e-1), coeffs))
        kernelPoints = [(P.push(phi), order, coeffs) for (P, order, coeffs) in kernelPoints]

        philist.append(phi)

    return EllipticCurveHom_composite.from_factors(philist)


#################################
#                               #
#      Simple translations      #
#                               #
#################################

def IdealToIsogenyGens(O0, I, PushedFacToBasis, facToAction):
    r"""
    Given a left O0 ideal I, and a basis (possibly pushed through an
    isogeny phi),
    returns points {phi(P_1), ..., phi(P_n)}, so that I corresponds
    to the isogeny generated by {P_1, ..., P_n}
    """
    N_I = I.norm()
    print(f'Translating ideal of norm {factor(N_I)}')
    alpha = IdealGenerator(I)
    alpha = alpha.conjugate() #Use the conjugate to project onto the kernel
    v_alpha = QuaternionOrderBasis(alpha, O0)
    ker_gens = []
    for l, e in factor(N_I):
        P, Q, PmQ = PushedFacToBasis[l**e]
        BasisAction = facToAction[l**e][:-1]
        M_alpha = sum(x*M for x, M in zip(v_alpha, BasisAction))
        a, b = M_alpha*vector([1,0])
        K = xDBLMUL(a, b, P, Q, PmQ)
        if not K.xMUL(l**(e-1)):
            a, b = M_alpha*vector([0,1])
            K = xDBLMUL(a, b, P, Q, PmQ)
            assert K.xMUL(l**(e-1))
        assert not K.xMUL(l**(e))
        ker_gens.append((K, (l,e), (a, b)))
    return ker_gens

def IdealToIsogeny(O0, I, E, pushedFacToBasis, facToAction):
    r"""
    Given a left O0 ideal I, and a basis (possibly pushed through an
    isogeny phi),
    returns the isogeny [phi]_*phi_I
    """
    ker_gens = IdealToIsogenyGens(O0, I, pushedFacToBasis, facToAction)
    return chain_iso(ker_gens, E)

def IsogenyGensToIdeal(O0, ker_gens, facToAction):    
    r"""
    Given generators ker_gens of an isogeny phi,
    returns the ideal I_phi
    """
    ideal_parts = []
    for K, (l,e), (c_1, c_2) in ker_gens:
        ideal_parts.append(KernelDecomposedToIdeal(O0, l**e, c_1, c_2, facToAction))
    I = O0*1
    for Im in ideal_parts:
        I = I.intersection(Im)
    return I

def KernelDecomposedToIdeal(O0, D, c_1, c_2, facToAction):
    r"""
    Given coefficients describing the kernel of 
    an isogeny phi, decomposed along a fixed basis,
    returns the ideal I_phi
    """
    i,j,k = O0.quaternion_algebra().gens()
    v_1 = vector(Integers(D), [c_1, c_2])
    _, M_i, M_ij, _, M_theta = facToAction[D]
    v_2 = M_theta*v_1
    M = Matrix(Integers(D), [v_1, v_2]).transpose()
    if M.det().is_unit():
        v_3 = M**(-1)*M_i*v_1
        a, b = [ZZ(c) for c in v_3]
        alpha = a + b*(j + (1+k)/2) - i
        M_alpha = a + b*M_theta - M_i
    else: #TODO: What are some actual distortion maps?
        v_2 = M_ij*v_1
        M = Matrix(Integers(D), [v_1, v_2]).transpose()
        v_3 = M**(-1)*M_i*v_1
        a, b = [ZZ(c) for c in v_3]
        alpha = a + b*(i+j)/2 - i
        M_alpha = a + b*M_ij - M_i
    assert M_alpha*v_1 == 0
    return O0*alpha + O0*D


#################################
#                               #
# Converting ell^\bullet ideals #
#                               #
#################################

def PushBasis(phi, FacToBasis):
    r"""
    Given an isogeny phi if degree 2^*, and a
    dictionary of torsion bases
    returns a dictionary containing
    the torsion bases pushed through phi
    """
    assert radical(phi.degree()) == 2 or radical(phi.degree()) == 1
    PushedFacToBasis = {}
    for key in FacToBasis.keys():
        if key%2 == 0: #Only want to push the prime power T-torsion
            continue
        PushedBasis = [R for R in FacToBasis[key]]
        PushedBasis = [R.push(phi) for R in FacToBasis[key]]
        PushedFacToBasis[key] = PushedBasis

        #### test
        l,e = factor(key)[0]
        P, Q, PmQ = PushedBasis
        assert P.xMUL(l**(e-1))
        assert not P.xMUL(l**e)

    return PushedFacToBasis

def IdealToIsogenyEichler(O0, O0_alt, I, J, pushedFacToBasis, facToAction, Q, f, T, I_secret = None):
    r"""
    Main idea:
    Given a left O-ideal I of norm 2^*, and a
    connecting an (O_0, O)-ideal J,
    returns phi_I

    Some additional parameters are required/returned,
    useful for signing
    """
    assert radical(I.norm()) == 2
    assert J.left_order() == O0
    assert I.left_order() == J.right_order()
    E0 = Q.curve()
    _, e = factor(I.norm())[0]
    g = ceil(e/f)
    Ji = J
    O = I.left_order()
    alpha = IdealGenerator(I)
    Ii = I + O*(2**f)
    first = False
    if J.norm() == 1:
        K = IdealToIsogenyGens(O0, Ii, pushedFacToBasis, facToAction)
        # Kinda dirty right now but oh well
        K = E0.lift_x(K[0][0].X)
        phi_I = customTwoIsogeny(K, f)
        Ji = Ii
        Oi = Ji.right_order()
        Iim = InverseIdeal(Ii)*I
        Ii = Iim + Oi*(2**f)
        Iim = InverseIdeal(Ii)*I

        Q_2f = CompleteBasis(K, 2**f)
        Q_2f = phi_I(Q_2f)
        assert Q_2f*(2**(f-1))
        pushedFacToBasis = PushBasis(phi_I, pushedFacToBasis)
        g = g-1
    else:
        phi_I = False
        Iim = InverseIdeal(Ii)*I
        Oi = O
        Q_2f = Q
        first = True
    Ki = Ji.conjugate() + Oi*(2**f)
    LRs = []
    CDs = []
    betas = []
    print("Initiating Ideal Steps")
    for step in range(g):
        print(f'>step: {step}')
        assert Ii.norm() == 2**f
        if step == 0 and I_secret:
            LRi, CDi, beta = IdealStep(T, O0, O0_alt, Ii, Ji, Ki, I_secret=I_secret)
        else:
            LRi, CDi, beta = IdealStep(T, O0, O0_alt, Ii, Ji, Ki)
        LRs.append(LRi)
        CDs.append(CDi)
        betas.append(beta)
        Ji = Ji*Ii
        Ki = Ii.conjugate()
        Oi = Ii.right_order()
        Ii = Iim + Oi*2**min(f, (g-(step+1))*f)
        Iim = InverseIdeal(Ii)*Iim
    print("Initiating Isogeny Steps")
    phi_Ii, Q_2f, s_1, b = IsogenyStep(O0, LRs[0], CDs[0], betas[0], Q_2f, pushedFacToBasis, facToAction, f, first=first)
    if phi_I:
        phi_I = phi_Ii * phi_I
    else:
        phi_I = phi_Ii
    zip = [b, [s_1]]
    for step in range(1, g):
        print(f'>Step: {step}')
        pushedFacToBasis = PushBasis(phi_Ii, pushedFacToBasis)
        phi_Ii, Q_2f, s_i, _ = IsogenyStep(O0, LRs[step], CDs[step], betas[step], Q_2f, pushedFacToBasis, facToAction, f)
        phi_I = phi_Ii * phi_I
        zip[1].append(s_i)
    return phi_I, zip, Q_2f

def IdealStep(T, O0, O0_alt, I, J, K, I_secret=None):
    r"""
    Subroutine of IdealToIsogenyEichler
    """
    O = I.left_order()
    beta = SpecialEichlerNorm(T, O0, O0_alt, J, K + O*2, I_secret=I_secret)
    assert beta not in O.intersection((K + O*2).right_order())
    assert beta in O
    C, D = FindLinearCombination(beta, I, K)
    n1 = T
    n2 = beta.reduced_norm()/T
    H1 = O*beta + O*n1
    H2 = O*beta.conjugate() + O*n2
    L = pullback(J, H1)
    R = pullback(J, H2)
    return (L, R), (C, D), beta

def IsogenyStep(O0, LR, CD, beta, Q_2f, pushedFacToBasis, facToAction, f, first=False):
    r"""
    Subroutine of IdealToIsogenyEichler
    """
    C, D = CD
    P_2f = CompleteBasis(Q_2f, 2**f)
    x_1, x_2 = EndomorphismAction(O0, LR, P_2f, Q_2f, beta, pushedFacToBasis, facToAction, f)
    # C*Q_2f + D*(beta(Q_2f)) = C*Q_2f + D*(x_1 * Q_2f + x_2 * P_2f)
    a_1 = D*x_2
    a_2 = C + D*x_1
    if first:
        G = a_1*P_2f + a_2*Q_2f
        P_2f, Q_2f = TorsionBasis(Q_2f.curve(), 2**f, xOnly=1)
        a_1, a_2 = BiDLP(G, P_2f, Q_2f, 2**f)
        if a_1 % 2 == 0:
            _temp = P_2f
            P_2f = Q_2f
            Q_2f = _temp
            s = (pow(a_2, -1, 2**f)*a_1) % 2**f
            b = 1
        else:            
            s = (pow(a_1, -1, 2**f)*a_2) % 2**f
            b = 0
        G = P_2f + s*Q_2f
    else:
        s = (pow(a_1, -1, 2**f)*a_2) % 2**f
        G = P_2f + s*Q_2f
        b = 0
    phi = customTwoIsogeny(G, f)
    pushedQ_2f = phi(Q_2f)
    return phi, pushedQ_2f, s, b

def EndomorphismAction(O0, LR, P_2f, Q_2f, beta, pushedFacToBasis, facToAction, f):
    r"""
    Finds the action of beta on a fixed 2^f-torsion basis P_2f, Q_2f.
    """
    L, R = LR
    twof = 2**f
    phi_1 = IdealToIsogeny(O0, L, Q_2f.curve(), pushedFacToBasis, facToAction)
    phi_2 = IdealToIsogeny(O0, R, Q_2f.curve(), pushedFacToBasis, facToAction)
    omega = phi_1.codomain().isomorphism_to(phi_2.codomain())
    phi_1 = omega * phi_1
    phi_1Q = phi_1(Q_2f)
    phi_1P = phi_1(P_2f)
    phi_2Q = phi_2(Q_2f)
    phi_2P = phi_2(P_2f)
    x_1, x_2 = BiDLP(phi_1Q, phi_2Q, phi_2P, 2**f)
    x_1 = (phi_2.degree()*x_1) % twof
    x_2 = (phi_2.degree()*x_2) % twof

    # ChineseSQIsign improvement:
    x_4 = (beta.reduced_trace() - x_1) % twof
    x_3 = ((x_1*x_4 - beta.reduced_norm()) * pow(x_2, -1, twof)) % twof
    testPoint = x_3*phi_2Q + x_4*phi_2P
    if testPoint != phi_2.degree()*phi_1P:
        x_1 = -x_1 % twof
        x_2 = -x_2 % twof
    
    return x_1, x_2
